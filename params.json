{
  "name": "Androidstarter",
  "tagline": "A sample Android app using the MVP architecture.",
  "body": "# Little stories about an Android application architecture\r\n\r\n![Android logo](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/logo_android.png)\r\n\r\nBy writing this paper, my goal is to describe how I came up with the Android app architecture I suggest.\r\nIt's a step by step writing to follow the reasons bringing me to set up the different components I chose.\r\n\r\nThe aim of the template application is very simple: it's a master/detail application to present a list of GitHub repositories of a given user.\r\nAlthough it's simple, it gathers some classical jobs when writing an application:\r\n\r\n* consume a REST API\r\n* save data to a local storage\r\n* load data from this local storage\r\n* architecture the logical layer and navigation between screens\r\n\r\nLet's discover what's hiding under the hood!\r\n\r\n***\r\n\r\n## Consuming REST API\r\n\r\n### REST Client\r\n\r\n[Retrofit](http://square.github.io/retrofit/) is a well-known library that comes back frequently when developers list \"must-have libraries\" for Android development.\r\n\r\nI'm going to explain why I consider it's a must-have library:\r\n\r\n* it's type-safe\r\n* the interface to write is human-readable, and annotations with path inside provide a useful mirror of the API\r\n* it provides a complete abstraction layer of how it works under the hood\r\n* it supports multipart request body (useful when you want to upload a file)\r\n* header management directly inside the interface using annotations\r\n* ability to use several serialization types (JSON, XML, protobuf, etc.) thanks to converters\r\n* possibility to add a global request interceptor (to set an authentication header with complex computation for each request for example)\r\n* it is easy to mock when testing\r\n\r\nIt's simple to add to a project through the following instruction in the `build.gradle` file:\r\n\r\n```groovy\r\n\tcompile 'com.squareup.retrofit:retrofit:{{last_version}}'\r\n```\r\n\r\nThen I can declare an interface called `GitHubService` that mirrors the API and declares the methods we need to consume this one:\r\n\r\n```java\r\npublic interface GitHubService {\r\n    @GET(\"/users/{user}/repos\")\r\n    Call<List<DTORepo>> listRepos(@Path(\"user\") final String psUser);\r\n}\r\n```\r\n\r\nNext I obtain an implementation of this interface thanks the `RestAdapter` class, as follows:\r\n\r\n```java\r\nfinal Retrofit loRetrofit = new Retrofit.Builder()\r\n\t.baseUrl(\"https://api.github.com\")\r\n\t.build();\r\n\r\nfinal GitHubService loService = loRetrofit.create(GitHubService.class);\r\nreturn loService;\r\n```\r\n\r\nAnother library I like to use is [Merlin](https://github.com/novoda/merlin). I see it as an utility tool to be aware of the network connectivity state and changes. It provides a fluent API, simple to set up inside an Android project.\r\n\r\nPersonally, to get the network connectivity state, I use its `MerlinsBeard` class that I can initialize like:\r\n\r\n```java\r\nfinal MerlinsBeard merlinsBeard = MerlinsBeard.from(context);\r\n```\r\n\r\nAnd then simple call to:\r\n\r\n```java\r\nmerlinsBeard.isConnected()\r\n```\r\n\r\ntells me if the network is reachable or not.\r\n\r\n### Parsing data\r\n\r\nSo, now we have our data coming from our remote server. It's time to describe how to process it in order to get our POJOs. A common format to interchange data is JSON. No surprise at this point. And if you are familiar with the Java world, no more surprise when I tell you I'm going to set up a JSON parser using [Jackson](https://github.com/FasterXML/jackson)! Obviously, no need to explain that Jackson is still one of the most popular libraries in this subject.\r\n\r\nNevertheless, I would like to add some criterion that make me love Jackson:\r\nFirst, I'm very satisfied with its fluent annotation API. And it's pretty helpful to be able to get and store properties that are not declared through the `@JsonProperty` annotation. Actually, here is some code to illustrate my words:\r\n\r\n```java\r\npublic class Example {\r\n\r\n\t@JsonIgnore\r\n\tprivate Map<String, Object> mAdditionalProperties = new HashMap<String, Object>();\r\n\t\r\n\t@JsonAnyGetter\r\n\tpublic Map<String, Object> getAdditionalProperties() {\r\n\t\treturn mAdditionalProperties;\r\n\t}\r\n\t\r\n\t@JsonAnySetter\r\n\tpublic void setAdditionalProperty(final String psName, final Object poValue) {\r\n\t\tmAdditionalProperties.put(psName, value poValue;\r\n\t}\r\n}\r\n```\r\n\r\nBut how useful could it be? \r\n\r\nJust think of an unusual behavior: I get a `NullPointerException` (for example) while processing my data. \r\n\r\nBut why? Simply because the JSON key has changed server-side.\r\n\r\nBut how could I see it if the API team did not let me know... A dive to the debugger and we can see that the `mAdditionalProperties` contains our expected value, but with a different key. And here we are! No more time wasted to debug this point.\r\n\r\n#### Combination with Retrofit\r\n\r\nCleverly, a dedicated Retrofit converter is available on GitHub: <https://github.com/square/retrofit/tree/master/retrofit-converters/jackson>.\r\n\r\nWe can simply add it to our `build.gradle` as follows:\r\n\r\n```groovy\r\ncompile 'com.squareup.retrofit2:converter-jackson:{{last_version}}'\r\n```\r\n\r\nAfter that, we simply need to set it to our previous `RestAdapter`:\r\n\r\n```java\r\nfinal Retrofit loRetrofit = new Retrofit.Builder()\r\n\t.baseUrl(\"https://api.github.com\")\r\n\t.addConverterFactory(JacksonConverterFactory.create()) // add the Jackson specific converter\r\n\t.build();\r\n\r\nfinal GitHubService loService = loRetrofit.create(GitHubService.class);\r\nreturn loService;\r\n```\r\n\r\n#### Bonus\r\n\r\nI frequently use the online tool named [_jsonschema2pojo_](http://www.jsonschema2pojo.org/). According to its description, it allows developers to\r\n> Generate Plain Old Java Objects from JSON or JSON-Schema.\r\n\r\nTo use it, we just have to paste a code snippet from the API, check the _JSON_ radio of the _Source type_ section. Using Jackson, I select the _Jackson 2.x_ radio under the _Annotation style_ section. Clicking on the _Preview_ button gives me a Java class representing the JSON mapping I need. It cleverly speeds up my development!\r\n\r\n#### An attractive alternative: Moshi\r\n\r\nWe can also adopt the emerging library provided by Square: [Moshi](https://github.com/square/moshi).\r\n\r\nThey also provide the corresponding [converter to configure Retrofit](https://github.com/square/retrofit/tree/master/retrofit-converters/moshi).\r\n\r\n#### Another attractive alternative: LoganSquare\r\n\r\nA powerful library named [LoganSquare](https://github.com/bluelinelabs/LoganSquare).\r\nIt relies on compile-time annotation processing to generate parsing/serializing code.\r\n\r\nWe can find converters written to make it work in combination with Retrofit:\r\n\r\n* <https://github.com/aurae/retrofit-logansquare> (officially referenced by the Retrofit's wiki pages)\r\n\r\n## Communication between components and passing data\r\n\r\nA frequently asked question in the Android ecosystem is:\r\n\r\n* how to make components communicate together, and optionally pass parameters?\r\n\r\nA common response is to set up an event bus.\r\n[A lot of libraries provide solution to this problem](http://android-arsenal.com/tag/32), among which:\r\n\r\n* [Otto](http://square.github.io/otto/)\r\n* [EventBus](http://greenrobot.github.io/EventBus/)\r\n* [TinyBus](https://github.com/beworker/tinybus)\r\n\r\nThey have various approaches and motivations. But the one I chose is Otto, because I find it easy to:\r\n\r\n* create a new bus instance\r\n* register to this bus instance\r\n* publish an event on this bus\r\n\r\nNothing revolutionary, isn't it?\r\n\r\nThe key point of my choice comes from the official documentation:\r\n\r\n> To subscribe to an event, annotate a method with `@Subscribe`. The method should take only a single parameter, the type of which will be the event you wish to subscribe to.\r\n\r\nI like the fact that I simply have to set the good parameter to my subscribing method to perform a specific job for each event.\r\n\r\nBut, the real point under the hood is the event inheritance. Indeed, if I define an `AbstractEventQueryDidFinish` (and I do so!), and then, for each query, a dedicated termination event such as `EventQueryADidFinish` and `EventQueryBDidFinish` for example, I'm able to:\r\n\r\n* define a method to be notified of a `EventQueryADidFinish` publication ;\r\n* define a method to be notified of a `EventQueryBDidFinish` publication ;\r\n* and, the most interesting for me, define a method to be notified of a `AbstractEventQueryDidFinish` publication.\r\n\r\nActually, it can be pretty useful to have a global interceptor that is notified when a query finished, with no matter how strong its type is.\r\n\r\nFor example, if you maintain a list of pending queries in an object (a synchronization engine for example), you can register this one to be notified of every `AbstractEventQueryDidFinish`.\r\nSo it becomes possible to refresh your pending queries list every time a request ends, and optionally store its result (failure or success).\r\n\r\n### Thread management\r\n\r\nOtto provides an API to define on which thread we publish an event.\r\nNevertheless, I defined my own bus subclass to ensure that the subscribers are notified on the main thread:\r\n\r\n```java\r\npublic class BusMainThread extends Bus {\r\n    //region Field\r\n    private final Handler mHandler = new Handler(Looper.getMainLooper());\r\n    //endregion\r\n\r\n    //region Constructor\r\n    public BusMainThread(final String psName) {\r\n        super(psName);\r\n    }\r\n    //endregion\r\n\r\n    //region Overridden method\r\n    @Override\r\n    public void post(final Object event) {\r\n        if (Looper.myLooper() == Looper.getMainLooper()) {\r\n            super.post(event);\r\n        } else {\r\n            mHandler.post(() -> BusMainThread.super.post(event));\r\n        }\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nFinally, to have a little more control on the type of events that are published, I defined an abstract class:\r\n\r\n```java\r\npublic abstract class AbstractEvent { }\r\n```\r\n\r\nAnd then, to provide a unified interface to communicate with the bus instances, I defined the following facade:\r\n\r\n```java\r\npublic final class BusManager {\r\n\r\n    //region Inner synthesize job\r\n    private static final Bus sBusAnyThread = new Bus(ThreadEnforcer.ANY, \"ANY_THREAD\");\r\n    private static final BusMainThread sBusMainThread = new BusMainThread(\"MAIN_THREAD\");\r\n    //endregion\r\n\r\n    //region Specific any thread job\r\n    public void registerSubscriberToBusAnyThread(final Object poSubscriber) {\r\n        if (poSubscriber != null) {\r\n            sBusAnyThread.register(poSubscriber);\r\n        }\r\n    }\r\n\r\n    public void unregisterSubscriberFromBusAnyThread(final Object poSubscriber) {\r\n        if (poSubscriber != null) {\r\n            sBusAnyThread.unregister(poSubscriber);\r\n        }\r\n    }\r\n\r\n    public void postEventOnAnyThread(final AbstractEvent poEvent) {\r\n        if (poEvent != null) {\r\n            sBusAnyThread.post(poEvent);\r\n        }\r\n    }\r\n    //endregion\r\n\r\n    //region Specific main thread job\r\n    public void registerSubscriberToBusMainThread(final Object poSubscriber) {\r\n        if (poSubscriber != null) {\r\n            sBusMainThread.register(poSubscriber);\r\n        }\r\n    }\r\n\r\n    public void unregisterSubscriberFromBusMainThread(final Object poSubscriber) {\r\n        if (poSubscriber != null) {\r\n            sBusMainThread.unregister(poSubscriber);\r\n        }\r\n    }\r\n\r\n    public void postEventOnMainThread(final AbstractEvent poEvent) {\r\n        if (poEvent != null) {\r\n            sBusMainThread.post(poEvent);\r\n        }\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\n## Managing jobs\r\n\r\nMultithreading and concurrency are recurrent developers' considerations. It comes in combination with one of the most important rule when developing an Android application: don't block the UI thread! It's kind of \"words of wisdom\" but it's important to keep it in mind permanently.\r\n\r\nSo, we can easily list some jobs that must not be done on the main thread:\r\n\r\n* calls to the remote API\r\n* database CRUD operations\r\n* read a local file\r\n* etc.\r\n\r\nFortunately, many resources come to the rescue: classes from the official Android SDK, blog posts, libraries and so on.\r\n\r\nBut one of the most useful resources I met is the \"Android REST client applications\" session from Google I/O 2010 by Virgil Dobjanschi:\r\n\r\n* <https://www.youtube.com/watch?v=xHXn3Kg2IQE>\r\n* <https://dl.google.com/googleio/2010/android-developing-RESTful-android-apps.pdf>\r\n\r\nAnd I totally agree with his advice that is:\r\n\r\n* use [`Service`](http://developer.android.com/reference/android/app/Service.html) class from the Android SDK\r\n* set up a `ServiceHelper` class to facade the call to network requests\r\n* have dedicated classes to process queries results (called `Processor` in this session)\r\n\r\nTo explain why the use of a `Service`, I'd just like to quote the official documentation:\r\n\r\n> A Service is an application component representing either an application's desire to perform a longer-running operation while not interacting with the user\r\n\r\nFor me, it's typically the meaning of the component that should perform my network requests. But we have to note that services\r\n> run in the main thread of their hosting process\r\n\r\nSo we still have to manage multithreading by ourselves. So we need a specific layer to perform queries asynchronously.\r\n\r\nYes, I know, Retrofit provides a mechanism to achieve this point. But I looked for a more generic layer, able to perform any job that needs to be done in background.\r\n\r\nAt this point, I discovered [Android Priority Job Queue (Job Manager)](https://github.com/yigit/android-priority-jobqueue).\r\n\r\n### Android Priority Job Queue (Job Manager)\r\n\r\nIt's probably one of the most documented, unit tested, powerful and reliable library I met. And it's based on the Google I/O brought up previously.\r\n\r\nTo set it up, we need to follow two steps.\r\n\r\n#### Job Manager Configuration\r\n\r\nThe `JobManager` is a key concept from this library. It's responsible for queuing up and performing jobs. It's designed to be as flexible as possible to allow the developer to build his own configuration.\r\n\r\nIt becomes possible to tell:\r\n\r\n* how many threads can consume jobs at the same time\r\n* how to persist jobs that cannot be performed at the moment\r\n* how to retrieve network connectivity status\r\n* which logger to use\r\n\r\nYou can find more information at the following URL: <https://github.com/yigit/android-priority-jobqueue/wiki/Job-Manager-Configuration>\r\n\r\nAs a sample, here is the configuration I use to perform network requests:\r\n\r\n```java\r\nfinal Configuration loConfiguration = new Configuration.Builder(poContext)\r\n\t.minConsumerCount(1) // always keep at least one consumer alive\r\n\t.maxConsumerCount(3) // up to 3 consumers at a time\r\n\t.loadFactor(3) // 3 jobs per consumer\r\n\t.consumerKeepAlive(120) // wait 2 minute\r\n\t.build();\r\n\r\nfinal JobManager loJobManager = new JobManager(poContext, loConfiguration);\r\n```\r\n\r\n#### Job Configuration\r\n\r\nA way I love with this library, is to consider each network request as a specific `Job`. This is that abstract class we must extend if we want to configure a job. Thanks to its constructor, it's highly-configurable. We can set some useful parameters to a job, as follow:\r\n\r\n* its priority\r\n* if it requires network to be performed\r\n* if it should persist if it cannot be performed\r\n* if it should run after some delay\r\n* its retry policy\r\n\r\nIt's also possible to group jobs so that they can be executed sequentially. It's pretty useful if you want to design a messaging client for example.\r\n\r\nAll necessary information about job configuration can be found on this page: <https://github.com/yigit/android-priority-jobqueue/wiki/Job-Configuration>\r\n\r\nThe persistence engine of this library is very powerful. For example, if the network is unreachable, jobs are serialized and persist on the device. Once the network becomes reachable, the `JobManager` fetches the persisting jobs and performs them as usual.\r\n\r\nI identified some redundant code when writing jobs to perform network requests. That's why I wrote an abstract class that every query should extend:\r\n\r\n```java\r\npublic abstract class AbstractQuery extends Job {\r\n    private static final String TAG = AbstractQuery.class.getSimpleName();\r\n    private static final boolean DEBUG = true;\r\n\r\n    protected enum Priority {\r\n        LOW(0),\r\n        MEDIUM(500),\r\n        HIGH(1000);\r\n        private final int value;\r\n\r\n        Priority(final int piValue) {\r\n            value = piValue;\r\n        }\r\n    }\r\n\r\n    protected boolean mSuccess;\r\n    protected Throwable mThrowable;\r\n    protected AbstractEventQueryDidFinish.ErrorType mErrorType;\r\n\r\n    //region Protected constructor\r\n    protected AbstractQuery(final Priority poPriority) {\r\n        super(new Params(poPriority.value).requireNetwork());\r\n    }\r\n\r\n    protected AbstractQuery(final Priority poPriority, final boolean pbPersistent, final String psGroupId, final long plDelayMs) {\r\n        super(new Params(poPriority.value).requireNetwork().setPersistent(pbPersistent).setGroupId(psGroupId).setDelayMs(plDelayMs));\r\n    }\r\n    //endregion\r\n\r\n    //region Overridden methods\r\n    @Override\r\n    public void onAdded() {\r\n    }\r\n\r\n    @Override\r\n    public void onRun() throws Throwable {\r\n        try {\r\n            execute();\r\n            mSuccess = true;\r\n        } catch (Throwable loThrowable) {\r\n            if (BuildConfig.DEBUG && DEBUG) {\r\n                Logger.t(TAG).e(loThrowable, \"\");\r\n            }\r\n            mErrorType = AbstractEventQueryDidFinish.ErrorType.UNKNOWN;\r\n            mThrowable = loThrowable;\r\n            mSuccess = false;\r\n        }\r\n\r\n        postEventQueryFinished();\r\n    }\r\n\r\n    @Override\r\n    protected void onCancel() {\r\n    }\r\n\r\n    @Override\r\n    protected int getRetryLimit() {\r\n        return 1;\r\n    }\r\n    //endregion\r\n\r\n    //region Protected abstract method for specific job\r\n    protected abstract void execute() throws Exception;\r\n\r\n    protected abstract void postEventQueryFinished();\r\n\r\n    public abstract void postEventQueryFinishedNoNetwork();\r\n    //endregion\r\n}\r\n```\r\n\r\nIt defines:\r\n\r\n* an `enum` describing available priorities I need\r\n* two constructors to provide both a simple and a complex way to build the query\r\n* the way to perform the specific code and how the exceptions are handled\r\n* a default retry limit\r\n\r\nWe can see that there are three methods to implement:\r\n\r\n* `execute`: the specific code to perform\r\n* `postEventQueryFinished`: the way to notify observers of the job termination (success or failure)\r\n* `postEventQueryFinishedNoNetwork`: the way to notify observers of the job termination because the network is unreachable\r\n\r\nThe two last methods are often based on the bus concept I talked about previously.\r\nConsidering I'm using Otto to communicate between components, here comes the abstract event I defined:\r\n\r\n```java\r\npublic abstract class AbstractEventQueryDidFinish<QueryType extends AbstractQuery> extends AbstractEvent {\r\n    public enum ErrorType {\r\n        UNKNOWN,\r\n        NETWORK_UNREACHABLE\r\n    }\r\n\r\n    public final QueryType query;\r\n\r\n    public final boolean success;\r\n    public final ErrorType errorType;\r\n    public final Throwable throwable;\r\n\r\n    public AbstractEventQueryDidFinish(final QueryType poQuery, final boolean pbSuccess, final ErrorType poErrorType, final Throwable poThrowable) {\r\n        query = poQuery;\r\n        success = pbSuccess;\r\n        errorType = poErrorType;\r\n        throwable = poThrowable;\r\n    }\r\n}\r\n```\r\n\r\nIt's designed to embed:\r\n\r\n* the query that just finished\r\n* the termination status\r\n* and, optionally, the type of error and `Throwable` objet that occurred\r\n\r\nEach query I defined could publish a specific event, subclassing `AbstractEventQueryDidFinish`, to notify about its termination with status.\r\n\r\nPutting it all together, here is a code snippet of the query I defined to get GitHub repositories of a given user:\r\n\r\n```java\r\npublic class QueryGetRepos extends AbstractQuery {\r\n    private static final String TAG = QueryGetRepos.class.getSimpleName();\r\n    private static final boolean DEBUG = true;\r\n\r\n    //region Fields\r\n    public final String user;\r\n    //endregion\r\n\r\n    //region Constructor matching super\r\n    protected QueryGetRepos(@NonNull final String psUser) {\r\n        super(Priority.MEDIUM);\r\n        user = psUser;\r\n    }\r\n    //endregion\r\n\r\n    //region Overridden method\r\n    @Override\r\n    protected void execute() throws Exception {\r\n        final GitHubService gitHubService = // specific code to get GitHubService instance\r\n\r\n        final Call<List<DTORepo>> loCall = gitHubService.listRepos(user);\r\n        final Response<List<DTORepo>> loExecute = loCall.execute();\r\n        final List<DTORepo> loBody = loExecute.body();\r\n\r\n        // TODO deal with list of DTORepo\r\n    }\r\n\r\n    @Override\r\n    protected void postEventQueryFinished() {\r\n        final EventQueryGetRepos loEvent = new EventQueryGetRepos(this, mSuccess, mErrorType, mThrowable);\r\n        busManager.postEventOnMainThread(loEvent);\r\n    }\r\n\r\n    @Override\r\n    public void postEventQueryFinishedNoNetwork() {\r\n        final EventQueryGetRepos loEvent = new EventQueryGetRepos(this, false, AbstractEventQueryDidFinish.ErrorType.NETWORK_UNREACHABLE, null);\r\n        busManager.postEventOnMainThread(loEvent);\r\n    }\r\n    //endregion\r\n\r\n    //region Dedicated EventQueryDidFinish\r\n    public static final class EventQueryGetRepos extends AbstractEventQueryDidFinish<QueryGetRepos> {\r\n        public EventQueryGetRepos(final QueryGetRepos poQuery, final boolean pbSuccess, final ErrorType poErrorType, final Throwable poThrowable) {\r\n            super(poQuery, pbSuccess, poErrorType, poThrowable);\r\n        }\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nAnd now, with a simple proxy class I call `QueryFactory` (it's very close to the `ServiceHelper` mentioned by Virgil Dobjanschi), I can easily start every request with a strong protocol to conform to:\r\n\r\n```java\r\npublic class QueryFactory {\r\n    //region Build methods\r\n    public QueryGetRepos buildQueryGetRepos(@NonNull final String psUser) {\r\n        return new QueryGetRepos(psUser);\r\n    }\r\n    //endregion\r\n\r\n    //region Start methods\r\n    public void startQuery(@NonNull final Context poContext, @NonNull final AbstractQuery poQuery) {\r\n        final Intent loIntent = new ServiceQueryExecutorIntentBuilder(poQuery).build(poContext);\r\n        poContext.startService(loIntent);\r\n    }\r\n\r\n    public void startQueryGetRepos(@NonNull final Context poContext, @NonNull final String psUser) {\r\n        final QueryGetRepos loQuery = buildQueryGetRepos(psUser);\r\n        startQuery(poContext, loQuery);\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nThe service to handle the query is declared as follows:\r\n\r\n```java\r\npublic class ServiceQueryExecutor extends IntentService {\r\n    private static final String TAG = ServiceQueryExecutor.class.getSimpleName();\r\n\r\n    //region Extra fields\r\n    AbstractQuery query;\r\n    //endregion\r\n\r\n    MerlinsBeard merlinsBeard;\r\n    JobManager jobManager;\r\n\r\n    //region Constructor matching super\r\n    /**\r\n     * Creates an IntentService.  Invoked by your subclass's constructor.\r\n     */\r\n    public ServiceQueryExecutor() {\r\n        super(TAG);\r\n    }\r\n    //endregion\r\n\r\n    //region Overridden methods\r\n    @DebugLog\r\n    @Override\r\n    protected void onHandleIntent(final Intent poIntent) {\r\n        // TODO get AbstractQuery from Intent \r\n        // TODO get MerlinsBeard and JobManager instances\r\n\r\n        // If query requires network, and if network is unreachable, and if the query must not persist\r\n        if (query.requiresNetwork() &&\r\n                !merlinsBeard.isConnected() &&\r\n                !query.isPersistent()) {\r\n            // then, we post an event to notify the job could not be done because of network connectivity\r\n            query.postEventQueryFinishedNoNetwork();\r\n        } else {\r\n            // otherwise, we can add the job\r\n            jobManager.addJobInBackground(query);\r\n        }\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nAnd here we have a consistent structure to manage network queries in a proper way that follows the guidelines from the Google I/O 2010.\r\n\r\n### RxJava\r\n\r\nAnother approach is to adopt [RxJava](https://github.com/ReactiveX/RxJava). It allows developers to build asynchronous programs with an event-based mechanism using `Observable`.\r\n\r\nReactiveX provides [Android specific bindings](https://github.com/ReactiveX/RxAndroid).\r\n\r\nIt can be pretty useful. We will see how I use it to perform CRUD operations on the database.\r\n\r\n## Data persistence\r\n\r\n### The ORM way\r\n\r\nIn software development, the Object-Relational Mapping (ORM) is a widely used technique. Different libraries exist for the various languages (Doctrine for PHP or Hibernate for Java for example).\r\n\r\nThe motivation to use an ORM is to easily set up and configure a SQLite database on Android.\r\nIt's also very powerful when setting up relationships. At least, it provides a very fluent API to execute CRUD operations on the database.\r\n\r\n#### OrmLite\r\n\r\n![OrmLite logo](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/logo_ormlite.png)\r\n\r\nThat's why I chose one of the most famous ORM on Android: [OrmLite](http://ormlite.com/sqlite_java_android_orm.shtml).\r\n\r\nThe first step is to set up our POJO to be mapped by ORMLite.\r\n\r\nI created an abstract class to match the classical Android approach with its `_id` column:\r\n\r\n```java\r\npublic abstract class AbstractOrmLiteEntity {\r\n    @DatabaseField(columnName = BaseColumns._ID, generatedId = true)\r\n    protected long _id;\r\n\r\n    //region Getter\r\n    public long getBaseId() {\r\n        return _id;\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nNow I simply create my POJO class (i.e., `RepoEntity` for this example):\r\n\r\n```java\r\n@DatabaseTable(tableName = \"REPO\", daoClass = DAORepo.class)\r\npublic class RepoEntity extends AbstractOrmLiteEntity {\r\n    @DatabaseField\r\n    public Integer id;\r\n\r\n    @DatabaseField\r\n    public String name;\r\n\r\n    @DatabaseField\r\n    public String location;\r\n\r\n    @DatabaseField\r\n    public String url;\r\n}\r\n```\r\n\r\nNow let's have a look at the DAO. This design pattern aims at accessing to the concrete data through an abstract interface. It describes and implements specific data operations to conform to the single responsibility principle.\r\n\r\nFortunately, OrmLite provides the [Dao interface](http://ormlite.com/javadoc/ormlite-core/com/j256/ormlite/dao/Dao.html) and its implementation: [BaseDaoImpl](http://ormlite.com/javadoc/ormlite-core/com/j256/ormlite/dao/BaseDaoImpl.html). All the traditional CRUD operations I need are available.\r\n\r\nUnfortunately, there are executed synchronously. That's where RxJava comes in handy to perform those operations asynchronously.\r\n\r\nSo I rewrote all the available methods in a RxJava way.\r\n\r\nSo I created an interface as follows:\r\n\r\n```java\r\npublic interface IRxDao<T, ID> extends Dao<T, ID>\r\n```\r\n\r\nwhere I declared all the available methods of `Dao` with the \"rx\" prefix. They all return an `Observable` object with the type of return from the standard method.\r\n\r\nThen I implemented this interface through an abstract class I declared like:\r\n\r\n```java\r\npublic abstract class RxBaseDaoImpl<DataType extends AbstractOrmLiteEntity, IdType> extends BaseDaoImpl<DataType, IdType> implements IRxDao<DataType, IdType>\r\n```\r\n\r\nAs I always use `long` as ID type, I define the following interface:\r\n\r\n```java\r\npublic interface IOrmLiteEntityDAO<DataType extends AbstractOrmLiteEntity> extends Dao<DataType, Long> {\r\n}\r\n```\r\n\r\nand abstract class:\r\n\r\n```java\r\npublic abstract class AbstractBaseDAOImpl<DataType extends AbstractOrmLiteEntity> extends RxBaseDaoImpl<DataType, Long> implements IOrmLiteEntityDAO<DataType> {\r\n    //region Constructors matching super\r\n    protected AbstractBaseDAOImpl(final Class<DataType> poDataClass) throws SQLException {\r\n        super(poDataClass);\r\n    }\r\n\r\n    public AbstractBaseDAOImpl(final ConnectionSource poConnectionSource, final Class<DataType> poDataClass) throws SQLException {\r\n        super(poConnectionSource, poDataClass);\r\n    }\r\n\r\n    public AbstractBaseDAOImpl(final ConnectionSource poConnectionSource, final DatabaseTableConfig<DataType> poTableConfig) throws SQLException {\r\n        super(poConnectionSource, poTableConfig);\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nSo the declaration of my `DAORepo` simply becomes:\r\n\r\n```java\r\npublic class DAORepo extends AbstractBaseDAOImpl<RepoEntity> {\r\n    //region Constructors matching super\r\n    public DAORepo(final ConnectionSource poConnectionSource) throws SQLException {\r\n        this(poConnectionSource, RepoEntity.class);\r\n    }\r\n\r\n    public DAORepo(final ConnectionSource poConnectionSource, final Class<RepoEntity> poDataClass) throws SQLException {\r\n        super(poConnectionSource, poDataClass);\r\n    }\r\n\r\n    public DAORepo(final ConnectionSource poConnectionSource, final DatabaseTableConfig<RepoEntity> poTableConfig) throws SQLException {\r\n        super(poConnectionSource, poTableConfig);\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nMoreover, ORMLite provides an abstract subclass of `SQLiteOpenHelper`, called `OrmLiteSqliteOpenHelper`. So, to declare our open helper, we simply have to write:\r\n\r\n```java\r\npublic class DatabaseHelperAndroidStarter extends OrmLiteSqliteOpenHelper {\r\n    private static final String DATABASE_NAME = \"android_starter.db\";\r\n    private static final int DATABASE_VERSION = 1;\r\n\r\n    //region Constructor\r\n    public DatabaseHelperAndroidStarter(@NonNull final Context poContext) {\r\n        super(poContext, DATABASE_NAME, null, DATABASE_VERSION);\r\n    }\r\n    //endregion\r\n\r\n    //region Methods to override\r\n    @Override\r\n    @SneakyThrows(SQLException.class)\r\n    public void onCreate(@NonNull final SQLiteDatabase poDatabase, @NonNull final ConnectionSource poConnectionSource) {\r\n        TableUtils.createTable(poConnectionSource, RepoEntity.class);\r\n    }\r\n\r\n    @Override\r\n    @SneakyThrows(SQLException.class)\r\n    public void onUpgrade(@NonNull final SQLiteDatabase poDatabase, @NonNull final ConnectionSource poConnectionSource, final int piOldVersion, final int piNewVersion) {\r\n        TableUtils.dropTable(poConnectionSource, RepoEntity.class, true);\r\n        onCreate(poDatabase, poConnectionSource);\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nWe can see that ORMLite provides the utility class [`TableUtils`](http://ormlite.com/javadoc/ormlite-core/com/j256/ormlite/table/TableUtils.html), where helpful methods can create or drop a table according to its mapped Java class.\r\n\r\nAt this time, don't pay attention to the `@SneakyThrows`. It comes from Lombok and is used to throw checked exceptions. Just remember that it allows us not to write the `try/catch` statement by ourselves, the annotation processor writes it for us.\r\n\r\nNow, it becomes very easy to deal with data. We just need a `DatabaseHelperAndroidStarter`:\r\n\r\n```java\r\npublic DatabaseHelperAndroidStarter getDatabaseHelperAndroidStarter(@NonNull final Context poContext) {\r\n\treturn new DatabaseHelperAndroidStarter(poContext);\r\n}\r\n```\r\n\r\nand we can get an instance of the `DAORepo` as follows:\r\n\r\n```java\r\npublic DAORepo getDAORepo(@NonNull final DatabaseHelperAndroidStarter poDatabaseHelperAndroidStarter) {\r\n\treturn new DAORepo(poDatabaseHelperAndroidStarter.getConnectionSource());\r\n}\r\n```\r\n\r\nIn a `Fragment`, we can get all the repo through the following call:\r\n\r\n```java\r\nprivate void rxGetRepos() {\r\n    mSubscriptionGetRepos = daoRepo.rxQueryForAll()\r\n            .subscribeOn(Schedulers.newThread())\r\n            .observeOn(AndroidSchedulers.mainThread())\r\n            .subscribe(\r\n                    (final List<RepoEntity> ploRepos) -> { // onNext\r\n                        // TODO deal with repos\r\n                    },\r\n                    (final Throwable poException) -> { // onError\r\n                        mSubscriptionGetRepos = null;\r\n                        // TODO deal with error\r\n                    },\r\n                    () -> { // onCompleted\r\n                       mSubscriptionGetRepos = null;\r\n                    }\r\n            );\r\n}\r\n```\r\n\r\nBut a question remains: how to get a repo from the network, parse it and store it in our database?\r\n\r\nA simple response could be to gather all annotations in the same Java class. But we obtain a class with the responsibilities of both the network and the database configuration.\r\n\r\nMy goal is to keep a class to interact with the network, `DTORepo` ; and one to map the database, `RepoEntity`. Basically, they have common fields, with the same names. So I need a tool to convert DTO to Entity. That's where [Android Transformer](https://github.com/txusballesteros/android-transformer) comes to the rescue:\r\n\r\n![Android Transformer logo](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/logo_transformer.png)\r\n\r\nIt provides two main annotations:\r\n\r\n* `@Mappable` to indicate the class it is mapped to\r\n* `@Mapped` to indicate a member should be mapped\r\n\r\nSo, our `RepoEntity` class becomes:\r\n\r\n```java\r\n@Mappable(with = DTORepo.class)\r\n@DatabaseTable(tableName = \"REPO\", daoClass = DAORepo.class)\r\npublic class RepoEntity extends AbstractOrmLiteEntity implements Serializable {\r\n    @Mapped\r\n    @DatabaseField\r\n    public Integer id;\r\n\r\n    @Mapped\r\n    @DatabaseField\r\n    public String name;\r\n\r\n    @Mapped\r\n    @DatabaseField\r\n    public String location;\r\n\r\n    @Mapped\r\n    @DatabaseField\r\n    public String url;\r\n}\r\n```\r\n\r\nAnd now we can transform a DTO to an Entity as follows:\r\n\r\n```java\r\nfinal Transformer loTransformerRepo = new Transformer.Builder().build(RepoEntity.class);\r\nfinal RepoEntity loRepo = loTransformerRepo.transform(loDTORepo, RepoEntity.class);\r\n```\r\n\r\n***\r\n\r\nAs a conclusion: \r\n\r\n* we have a simple way to define a new class mapping a SQLite table\r\n* we conform to the single responsibility principle by providing a dedicated implementation of `AbstractBaseDAOImpl`\r\n* we access to CRUD operations, in an asynchronous way, thanks to RxJava \r\n\r\nNote that we can boost the DAOs creations by generating an ORMLite configuration file at compile-time thanks to the [\"ormgap\" plugin](https://github.com/stephanenicolas/ormlite-android-gradle-plugin).\r\n\r\n***\r\n\r\n### The `ContentProvider` way\r\n\r\nA widely used approach is to set up a [`ContentProvider`](http://developer.android.com/reference/android/content/ContentProvider.html). Personally, I came to it thanks to the [_iosched_ open-source application by Google](https://github.com/google/iosched). That's where I saw how to configure and use this concept.\r\n\r\nI'd like to say that I find that it's a powerful mechanism, especially when it's used in combination with [`Cursor`](http://developer.android.com/reference/android/database/Cursor.html) and its derivatives like [`CursorLoader`](http://developer.android.com/reference/android/content/CursorLoader.html) and [`CursorAdapter`](http://developer.android.com/reference/android/widget/CursorAdapter.html).\r\n\r\nIt's efficient and reliable. Moreover, it can be boosted up with some tips like overriding the `bulkInsert` method and use a single SQL transaction.\r\n\r\nThe only thing I regret is that it's not pretty to set up and we have to write a lot of boilerplate code.\r\nThat's why I looked for a simpler solution to easily declare my content provider, but also to maintain control over the implementation of some methods of the content provider. In other words, I must deal with a `ContentProvider` subclass.\r\n\r\nThat's why I like [ProviGen](https://github.com/TimotheeJeannin/ProviGen).\r\n\r\nHere are the advantages I see:\r\n\r\n* it's simple to declare a [contract class](http://developer.android.com/guide/topics/providers/content-provider-basics.html#ContractClasses), a common practice when using content providers\r\n* we deal with a `ProviGenProvider`, that is a subclass of `ContentProvider`\r\n* it provides a default implementation of the `SQLiteOpenHelper`\r\n* it's possible to provide a custom implementation of the `SQLiteOpenHelper`\r\n* a `TableBuilder` class is available to help developers building their SQL tables with a fluent API\r\n\r\nEach \"model\" class has its own contract class.\r\nIn a few lines, the `ProviGenProvider` subclass provides a way to register all these contract classes.\r\n\r\nIt becomes very fast to set up a basic content provider. To maintain control over this implementation, we can \r\n\r\n* add custom URIs and deal with it (for more complex jobs for example)\r\n* speed up the content provider performances\r\n\r\nAnother tool I like to speed up content provider management is [MicroOrm](https://github.com/chalup/microorm). Just annotate your POJO with `@Column`, giving it the name of the column to bind (the constant coming from the contract class is perfect for that!), and then you can:\r\n\r\n* build [`ContentValues`](http://developer.android.com/reference/android/content/ContentValues.html) easily through a `MicroOrm` instance and its `toContentValues` method, taking a POJO instance as parameter\r\n* build a POJO instance from a `Cursor` thanks to the `fromCursor` method of the `MicroOrm` instance\r\n* build a list of POJO from a `Cursor` thanks to the `listFromCursor` method of the `MicroOrm` instance\r\n\r\nIt's a very simple way to deal with `Cursor` and `ContentValues`, unavoidable when using a content provider.\r\n\r\n## Dependency injection\r\n\r\nThe dependency injection (a.k.a. \"DI\") is a powerful design pattern that implements \"inversion of control\" (IoC) to resolve dependencies.\r\n\r\nNo need to remind you how useful can be the DI:\r\n\r\n* easy to read\r\n* easy to maintain\r\n* easy to test (because it's easy to mock an element)\r\n\r\nA major solution to use DI on Android is [Dagger2](http://google.github.io/dagger/). The main advantage I see is that the dependency analysis is done at compile time. So potential errors are notified as soon as possible.\r\n\r\nThis is not the place to detail all the capabilities of Dagger2. \r\n[This article, written by Kerry Perez Huanca](http://code.tutsplus.com/tutorials/dependency-injection-with-dagger-2-on-android--cms-23345), provides a good summary of the Dagger2 workflow with its key concepts:\r\n\r\n1. Identify the dependent objects and their dependencies.\r\n2. Create a class with the `@Module` annotation, using the `@Provides` annotation for every method that returns a dependency.\r\n3. Request dependencies in your dependent objects using the `@Inject` annotation.\r\n4. Create an interface using the `@Component` annotation and add the classes with the `@Module` annotation created in the second step.\r\n5. Create an object of the `@Component` interface to instantiate the dependent objects with their dependencies.\r\n\r\nTo have a full taste of Dagger2, I suggest you to read this [excellent article written by Fernando Cejas](http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/).\r\n\r\nNow, according to our sample project, following the workflow described up above, let's set up Dagger2 in the project.\r\n\r\n#### 1. Identify the dependent objects and their dependencies:\r\n\r\n* the `ServiceQueryExecutor` requires an instance of `JobManager`\r\n* the `ServiceQueryExecutor` requires an instance of `MerlinsBeard`\r\n* each query needs a `BusManager` to publish its termination\r\n* each observer (`Fragment` for example) requires a `BusManager` to register and listen for queries termination\r\n* each DAO needs a `DatabaseHelperAndroidStarter` to be built successfully\r\n* some queries need a `DAORepo` to delete, insert or update a repo\r\n* some queries need a `Transformer` to convert `DTORepo` to `RepoEntity`\r\n* some elements need a `DAORepo` to query a repo\r\n* all queries needs a `GitHubService` to perform REST calls\r\n* invoking elements requires an instance of `QueryFactory` to start REST calls\r\n\r\n#### 2. It's now time to have a look at our modules, for example:\r\n\r\n* `ModuleAsync`:\r\n\r\n```java\r\n@Module\r\npublic class ModuleAsync {\r\n\r\n    @Provides\r\n    @Singleton\r\n    public JobManager provideJobManager(@NonNull final Context poContext) {\r\n        final Configuration loConfiguration = new Configuration.Builder(poContext)\r\n                .minConsumerCount(1) // always keep at least one consumer alive\r\n                .maxConsumerCount(3) // up to 3 consumers at a time\r\n                .loadFactor(3) // 3 jobs per consumer\r\n                .consumerKeepAlive(120) // wait 2 minute\r\n                .build();\r\n        return new JobManager(poContext, loConfiguration);\r\n    }\r\n}\r\n```\r\n\r\n* `ModuleBus`:\r\n\r\n```java\r\n@Module\r\npublic class ModuleBus {\r\n\r\n    @Provides\r\n    @Singleton\r\n    public BusManager provideBusManager() {\r\n        return new BusManager();\r\n    }\r\n}\r\n```\r\n\r\n* `ModuleContext`:\r\n\r\n```java\r\n@Module\r\npublic class ModuleContext {\r\n    private final Context mContext;\r\n\r\n    public ModuleContext(@NonNull final Context poContext) {\r\n        mContext = poContext;\r\n    }\r\n\r\n    @Provides\r\n    public Context provideContext() {\r\n        return mContext;\r\n    }\r\n}\r\n```\r\n\r\n* `ModuleDatabase`:\r\n\r\n```java\r\n@Module\r\npublic class ModuleDatabase {\r\n    private static final String TAG = ModuleDatabase.class.getSimpleName();\r\n    private static final boolean DEBUG = true;\r\n\r\n    @Provides\r\n    @Singleton\r\n    public DatabaseHelperAndroidStarter provideDatabaseHelperAndroidStarter(@NonNull final Context poContext) {\r\n        return new DatabaseHelperAndroidStarter(poContext);\r\n    }\r\n\r\n    @Provides\r\n    @Singleton\r\n    public DAORepo provideDAORepo(@NonNull final DatabaseHelperAndroidStarter poDatabaseHelperAndroidStarter) {\r\n        try {\r\n            final ConnectionSource loConnectionSource = poDatabaseHelperAndroidStarter.getConnectionSource();\r\n            final DatabaseTableConfig<RepoEntity> loTableConfig = DatabaseTableConfigUtil.fromClass(loConnectionSource, RepoEntity.class);\r\n            if(loTableConfig != null) {\r\n                return new DAORepo(loConnectionSource, loTableConfig);\r\n            } else {\r\n                return new DAORepo(loConnectionSource);\r\n            }\r\n        } catch (final SQLException loException) {\r\n            if (BuildConfig.DEBUG && DEBUG) {\r\n                Logger.t(TAG).e(loException, \"\");\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n* `ModuleEnvironment`:\r\n\r\n```java\r\n@Module\r\npublic class ModuleEnvironment {\r\n\r\n    @Provides\r\n    @Singleton\r\n    public IEnvironment provideEnvironment() {\r\n        return BuildConfig.ENVIRONMENT;\r\n    }\r\n}\r\n```\r\n\r\n* `ModuleRest`:\r\n\r\n```java\r\n@Module\r\npublic class ModuleRest {\r\n\r\n    @Provides\r\n    @Singleton\r\n    public OkHttpClient provideOkHttpClient(@NonNull final IEnvironment poEnvironment) {\r\n        final HttpLoggingInterceptor loHttpLoggingInterceptor = new HttpLoggingInterceptor();\r\n        loHttpLoggingInterceptor.setLevel(poEnvironment.getHttpLoggingInterceptorLevel());\r\n        return new OkHttpClient.Builder()\r\n                .addInterceptor(loHttpLoggingInterceptor)\r\n                .build();\r\n    }\r\n\r\n    @Provides\r\n    @Singleton\r\n    public GitHubService provideGithubService(@NonNull final OkHttpClient poOkHttpClient) {\r\n        final Retrofit loRetrofit = new Retrofit.Builder()\r\n                .baseUrl(\"https://api.github.com\")\r\n                .client(poOkHttpClient)\r\n                .addConverterFactory(JacksonConverterFactory.create())\r\n                .addCallAdapterFactory(new ErrorHandlingExecutorCallAdapterFactory(new ErrorHandlingExecutorCallAdapterFactory.MainThreadExecutor()))\r\n                .build();\r\n        return loRetrofit.create(GitHubService.class);\r\n    }\r\n\r\n    @Provides\r\n    @Singleton\r\n    public QueryFactory provideQueryFactory() {\r\n        return new QueryFactory();\r\n    }\r\n\r\n    @Provides\r\n    @Singleton\r\n    public Merlin provideMerlin(@NonNull final Context poContext) {\r\n        return new Merlin.Builder()\r\n                .withConnectableCallbacks()\r\n                .withDisconnectableCallbacks()\r\n                .withBindableCallbacks()\r\n                .withLogging(true)\r\n                .build(poContext);\r\n    }\r\n\r\n    @Provides\r\n    @Singleton\r\n    public MerlinsBeard provideMerlinsBeard(@NonNull final Context poContext) {\r\n        return MerlinsBeard.from(poContext);\r\n    }\r\n\r\n    @Provides\r\n    @Singleton\r\n    public Picasso providePicasso(@NonNull final Context poContext) {\r\n        final Picasso loPicasso = Picasso.with(poContext);\r\n        loPicasso.setIndicatorsEnabled(true);\r\n        loPicasso.setLoggingEnabled(true);\r\n        return loPicasso;\r\n    }\r\n\r\n    @Provides\r\n    @Singleton\r\n    public PicassoModule providePicassoModule(@NonNull final Picasso poPicasso) {\r\n        return  new PicassoModule(poPicasso);\r\n    }\r\n}\r\n```\r\n\r\n* `ModuleTransformer`:\r\n\r\n```java\r\n@Module\r\npublic class ModuleTransformer {\r\n    public static final String TRANSFORMER_REPO = \"TRANSFORMER_REPO\";\r\n\r\n    @Provides\r\n    @Singleton\r\n    @Named(TRANSFORMER_REPO)\r\n    public Transformer provideTransformerRepo() {\r\n        return new Transformer.Builder()\r\n                .build(RepoEntity.class);\r\n    }\r\n}\r\n```\r\n\r\nConcerning the last one, `ModuleTransformer`, as it's impossible to strongly type an instance of `Transformer`, we use the naming convention thanks to the `@Named` annotation.\r\n\r\nIt now can be injected like:\r\n\r\n```java\r\n@Inject\r\n@Named(ModuleTransformer.TRANSFORMER_REPO)\r\nTransformer transformerRepo;\r\n```\r\n\r\nTo speed up the set up of components, I use the annotations-based [Auto-Dagger2](https://github.com/lukaspili/Auto-Dagger2) library. Annotations are processed at compilation time to generate the boilerplate code of the components.\r\n\r\nOn the one hand, I've to declare my `Application` subclass like this:\r\n\r\n```java\r\n@AutoComponent(\r\n        modules = {\r\n                ModuleAsync.class,\r\n                ModuleBus.class,\r\n                ModuleContext.class,\r\n                ModuleDatabase.class,\r\n                ModuleEnvironment.class,\r\n                ModuleRest.class,\r\n                ModuleTransformer.class\r\n        }\r\n)\r\n@Singleton\r\npublic class ApplicationAndroidStarter extends MultiDexApplication\r\n```\r\n\r\nThe `@AutoComponent` lists all the modules to provide it in the generated component.\r\n\r\nOn the other hand, on each element that needs injected elements, I add the `@AutoInjector(ApplicationAndroidStarter.class)` annotation, pointing on the class annotated with `@AutoComponent`. This way, I obtain a valid component declaration, auto-generated, as follows:\r\n\r\n```java\r\n@Component(\r\n    modules = {\r\n        ModuleAsync.class,\r\n        ModuleBus.class,\r\n        ModuleContext.class,\r\n        ModuleDatabase.class,\r\n        ModuleEnvironment.class,\r\n        ModuleRest.class,\r\n        ModuleTransformer.class\r\n    }\r\n)\r\n@Singleton\r\npublic interface ApplicationAndroidStarterComponent {\r\n  void inject(ApplicationAndroidStarter applicationAndroidStarter);\r\n\r\n  void inject(ServiceQueryExecutor serviceQueryExecutor);\r\n\r\n  void inject(QueryGetRepos queryGetRepos);\r\n\r\n  void inject(FragmentRepoList fragmentRepoList);\r\n\r\n  // ...\r\n\r\n}\r\n```\r\n\r\nIt allows me not to write the code of the component, and not to add manually an `inject` method each time a new element needs injections.\r\n\r\nFor example, my `ServiceQueryExecutor` is simply declared as follows:\r\n\r\n```java\r\n@AutoInjector(ApplicationAndroidStarter.class)\r\npublic class ServiceQueryExecutor extends IntentService\r\n```\r\n\r\nWhat a precious time saving, isn't it?\r\n\r\n## The MVP architecture\r\n\r\nAs an introduction to the MVP architecture, its motivations and its benefits, I invite you to read the [very interesting website](http://hannesdorfmann.com/mosby/) coming with the [Mosby library](https://github.com/sockeqwe/mosby).\r\n\r\nAll you need to know about [MVP fundamentals](http://hannesdorfmann.com/mosby/mvp/), [ViewState](http://hannesdorfmann.com/mosby/viewstate/) and LCE (Loading-Content-Error) is well explained in this website.\r\n\r\nAnother useful tool is the [Android DataBinding library](http://developer.android.com/tools/data-binding/guide.html). Using this one makes our _View_ and our _Model_ tightly coupled and having a bidirectional binding. It's the glue we were missing. With a few configurations, we can plug the view (its `layout.xml` file and `Activity`/`Fragment`) to the model (traditionally, a POJO). I let the official documentation tells you how to use this library.\r\n\r\nTo explain the MVP architecture using Mosby, I'm going to present the use case of _displaying the detail of a repo_.\r\n\r\nThe first step is to design the model class corresponding to the screen we are going to display:\r\n\r\n```java\r\npublic final class ModelRepoDetail {\r\n    public final RepoEntity repo; // the repo to display\r\n\r\n    public ModelRepoDetail(final RepoEntity poRepo) {\r\n        repo = poRepo;\r\n    }\r\n}\r\n```\r\n\r\nNow we define the corresponding _View_ interface:\r\n\r\n```java\r\npublic interface ViewRepoDetail extends MvpLceView<ModelRepoDetail> {\r\n    void showEmpty();\r\n}\r\n```\r\n\r\nThe next step is to define the presenter:\r\n\r\n```java\r\n@AutoInjector(ApplicationAndroidStarter.class) // to automatically add inject method in component\r\npublic final class PresenterRepoDetail extends MvpBasePresenter<ViewRepoDetail> {\r\n\r\n    //region Injected fields\r\n    @Inject\r\n    DAORepo daoRepo; // we need the DAO to load the repo from its ID\r\n    //endregion\r\n\r\n    //region Fields\r\n    private Subscription mSubscriptionGetRepo; // the RxJava subscription, to destroy it when needed\r\n    //endregion\r\n\r\n    //region Constructor\r\n    public PresenterRepoDetail() {\r\n        // inject necessary fields via the component\r\n        ApplicationAndroidStarter.sharedApplication().componentApplication().inject(this);\r\n    }\r\n    //endregion\r\n\r\n    //region Visible API\r\n    public void loadRepo(final long plRepoId, final boolean pbPullToRefresh) {\r\n        if (isViewAttached()) {\r\n            getView().showLoading(pbPullToRefresh);\r\n        }\r\n        // get repo asynchronously via RxJava\r\n        rxGetRepo(plRepoId);\r\n    }\r\n\r\n    public void onDestroy() {\r\n        // destroy the RxJava subscribtion\r\n        if (mSubscriptionGetRepo != null) {\r\n            mSubscriptionGetRepo.unsubscribe();\r\n            mSubscriptionGetRepo = null;\r\n        }\r\n    }\r\n    //endregion\r\n\r\n    //region Reactive job\r\n    private void rxGetRepo(final long plRepoId) {\r\n        mSubscriptionGetRepo = getDatabaseRepo(plRepoId)\r\n                .subscribeOn(Schedulers.newThread())\r\n                .observeOn(AndroidSchedulers.mainThread())\r\n                .subscribe(\r\n                        (final RepoEntity poRepo) -> { // onNext\r\n                            if (isViewAttached()) {\r\n                                getView().setData(new ModelRepoDetail(poRepo));\r\n                                if (poRepo == null) {\r\n                                    getView().showEmpty();\r\n                                } else {\r\n                                    getView().showContent();\r\n                                }\r\n                            }\r\n                        },\r\n                        (final Throwable poException) -> { // onError\r\n                            mSubscriptionGetRepo = null;\r\n                            if (isViewAttached()) {\r\n                                getView().showError(poException, false);\r\n                            }\r\n                        },\r\n                        () -> { // onCompleted\r\n                            mSubscriptionGetRepo = null;\r\n                        }\r\n                );\r\n    }\r\n    //endregion\r\n\r\n    //region Database job\r\n    @RxLogObservable\r\n    private Observable<RepoEntity> getDatabaseRepo(final long plRepoId) {\r\n        return daoRepo.rxQueryForId(plRepoId);\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nThe main code is placed in the `rxGetRepo` method: it loads data from the database and asks the view to configure itself according to the result (success: it should display data ; failure: it should display an error).\r\n\r\nAnd now, let's have a look at the `FragmentRepoDetail`. Considering Mosby explanation, this fragment is part of the _View_. So, it should implement the `ViewRepoDetail` we defined. To be the closest to Mosby API, we make it inherit from `MvpFragment`, providing generic types `ViewRepoDetail` (for the _View_) and `PresenterRepoDetail` (for the _Presenter_).\r\n\r\nSo what we get:\r\n\r\n```java\r\n@FragmentWithArgs\r\npublic class FragmentRepoDetail\r\n        extends MvpFragment<ViewRepoDetail, PresenterRepoDetail>\r\n        implements ViewRepoDetail {\r\n\r\n    //region FragmentArgs\r\n    @Arg\r\n    Long mItemId;\r\n    //endregion\r\n\r\n    //region Fields\r\n    private Switcher mSwitcher;\r\n    //endregion\r\n\r\n    //region Injected views\r\n    @Bind(R.id.FragmentRepoDetail_TextView_Empty)\r\n    TextView mTextViewEmpty;\r\n    @Bind(R.id.FragmentRepoDetail_TextView_Error)\r\n    TextView mTextViewError;\r\n    @Bind(R.id.FragmentRepoDetail_ProgressBar_Loading)\r\n    ProgressBar mProgressBarLoading;\r\n    @Bind(R.id.FragmentRepoDetail_ContentView)\r\n    LinearLayout mContentView;\r\n    //endregion\r\n\r\n    //region Data-binding\r\n    private FragmentRepoDetailBinding mBinding;\r\n    //endregion\r\n\r\n    //region Default constructor\r\n    public FragmentRepoDetail() {\r\n    }\r\n    //endregion\r\n\r\n    //region Lifecycle\r\n    @Override\r\n    public void onCreate(final Bundle poSavedInstanceState) {\r\n        super.onCreate(poSavedInstanceState);\r\n        FragmentArgs.inject(this);\r\n    }\r\n\r\n    @Override\r\n    public View onCreateView(final LayoutInflater poInflater, final ViewGroup poContainer,\r\n                             final Bundle savedInstanceState) {\r\n        mBinding = DataBindingUtil.inflate(poInflater, R.layout.fragment_repo_detail, poContainer, false);\r\n        return mBinding.getRoot();\r\n    }\r\n\r\n    @Override\r\n    public void onViewCreated(final View poView, final Bundle poSavedInstanceState) {\r\n        super.onViewCreated(poView, poSavedInstanceState);\r\n\r\n        ButterKnife.bind(this, poView);\r\n\r\n        mSwitcher = new Switcher.Builder()\r\n                .withEmptyView(mTextViewEmpty)\r\n                .withProgressView(mProgressBarLoading)\r\n                .withErrorView(mTextViewError)\r\n                .withContentView(mContentView)\r\n                .build();\r\n\r\n        loadData(false);\r\n    }\r\n\r\n    @Override\r\n    public void onDestroyView() {\r\n        super.onDestroyView();\r\n\r\n        ButterKnife.unbind(this);\r\n\r\n        if (mBinding != null) {\r\n            mBinding.unbind();\r\n            mBinding = null;\r\n        }\r\n    }\r\n    //endregion\r\n\r\n    //region MvpFragment\r\n    @Override\r\n    public PresenterRepoDetail createPresenter() {\r\n        return new PresenterRepoDetail();\r\n    }\r\n    //endregion\r\n\r\n    //region ViewRepoDetail\r\n    @Override\r\n    public void showEmpty() {\r\n        mSwitcher.showEmptyView();\r\n    }\r\n    //endregion\r\n\r\n    //region MvpLceView\r\n    @Override\r\n    public void showContent() {\r\n        mSwitcher.showContentView();\r\n    }\r\n\r\n    @Override\r\n    public void showLoading(final boolean pbPullToRefresh) {\r\n        mSwitcher.showProgressView();\r\n    }\r\n\r\n    @Override\r\n    public void showError(final Throwable poThrowable, final boolean pbPullToRefresh) {\r\n        mSwitcher.showErrorView();\r\n    }\r\n\r\n    @Override\r\n    public void setData(final ModelRepoDetail poData) {\r\n        mBinding.setRepo(poData.repo);\r\n\r\n        final Activity loActivity = this.getActivity();\r\n        final CollapsingToolbarLayout loAppBarLayout = (CollapsingToolbarLayout) loActivity.findViewById(R.id.ActivityRepoDetail_ToolbarLayout);\r\n        if (loAppBarLayout != null) {\r\n            loAppBarLayout.setTitle(poData.repo.url);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void loadData(final boolean pbPullToRefresh) {\r\n        if (mItemId == null) {\r\n            mSwitcher.showErrorView();\r\n        } else {\r\n            getPresenter().loadRepo(mItemId.longValue(), pbPullToRefresh);\r\n        }\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nAt this point, don't worry, some annotations and classes are going to be described in a next section (`@FragmentArgsInherited`, `@Arg`, `@Bind`, `FragmentArgs`, `ButterKnife` and `Switcher`).\r\n\r\nFinally, just have a look at the corresponding layout:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n        xmlns:tools=\"http://schemas.android.com/tools\">\r\n\r\n    <data>\r\n        <variable\r\n            name=\"repo\"\r\n            type=\"fr.guddy.androidstarter.database.entities.RepoEntity\"/>\r\n    </data>\r\n\r\n    <FrameLayout\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\"\r\n        android:orientation=\"vertical\">\r\n\r\n        <TextView\r\n            android:id=\"@+id/FragmentRepoDetail_TextView_Empty\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"match_parent\"\r\n            android:gravity=\"center\"\r\n            android:text=\"@string/empty_repo\"/>\r\n\r\n        <TextView\r\n            android:id=\"@+id/FragmentRepoDetail_TextView_Error\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"match_parent\"\r\n            android:gravity=\"center\"\r\n            android:text=\"@string/error_repo\"/>\r\n\r\n        <ProgressBar\r\n            android:id=\"@+id/FragmentRepoDetail_ProgressBar_Loading\"\r\n            style=\"?android:attr/progressBarStyleLarge\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_gravity=\"center\"/>\r\n\r\n        <LinearLayout\r\n            android:id=\"@+id/FragmentRepoDetail_ContentView\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"match_parent\"\r\n            android:orientation=\"vertical\">\r\n\r\n            <TextView\r\n                android:id=\"@+id/FragmentRepoDetail_TextView_Name\"\r\n                style=\"?android:attr/textAppearanceLarge\"\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:padding=\"16dp\"\r\n                android:text=\"@{repo.name}\"\r\n                android:textIsSelectable=\"true\"/>\r\n\r\n            <TextView\r\n                android:id=\"@+id/FragmentRepoDetail_TextView_Location\"\r\n                style=\"?android:attr/textAppearanceMedium\"\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:padding=\"16dp\"\r\n                android:text=\"@{repo.location}\"\r\n                android:textIsSelectable=\"true\"/>\r\n\r\n            <TextView\r\n                android:id=\"@+id/FragmentRepoDetail_TextView_Url\"\r\n                style=\"?android:attr/textAppearanceSmall\"\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:padding=\"16dp\"\r\n                android:text=\"@{repo.url}\"\r\n                android:textIsSelectable=\"true\"/>\r\n        </LinearLayout>\r\n    </FrameLayout>\r\n</layout>\r\n```\r\n\r\nWe can see the different views we are going to play with (the _LCE_). And we can see the DataBinding in action to bind views to the model we defined.\r\n\r\nThanks to the MVP architecture we set, we gain a lot when structuring our code:\r\n\r\n* a dedicated class to load and present the suitable data: the _Presenter_\r\n* a class to represent the data we should display: the _Model_\r\n* a tuple <`Fragment`, layout> to represent the way we display data: the _View_\r\n\r\nWith this well-structured and decoupled approach, it's easy to add a new screen, organize its code and maintain the project. Moreover, the presenter (where all the business logic takes place) can be easily unit tested by mocking the _View_ part.\r\n\r\n## Write thinner classes\r\n\r\nHaving in mind the huge number of _listeners_, the boilerplate code to display specific views and content, handling user interactions (button click, text changes, menu item click)... and so on, it's common to write `Activity`/`Fragment` with a huge number of lines, methods and interfaces. It could become very difficult to read these files.\r\n\r\nThis section aims at writing this code in a different way:\r\n\r\n* is it possible to reorganize it in meaningful layers?\r\n* is it possible to get rid of boilerplate code and automate its generation?\r\n\r\nI'm going to give some ideas to answer these questions.\r\n\r\n### Benefits of Java annotations and Annotation Processing Tool (APT)\r\n\r\nA major step forward in Android development was the release of the [`android-apt`](https://bitbucket.org/hvisser/android-apt) project, by Hugo Visser.\r\n\r\nIt allows developers to configure, in the gradle build file, the compile-time annotation processing. Most of the time, libraries using it generate the boilerplate code developer should not have to write.\r\n\r\nLet's have a look to some libraries using Java annotations to drastically simplify Android development, and sometimes built upon `android-apt`.\r\n\r\n#### Butter Knife\r\n\r\n* <http://jakewharton.github.io/butterknife/>\r\n \r\nA definitely \"must-have library\", quoted in every listing!\r\n\r\nIt has annotations processor to bind a lot of resources considerations to Java code:\r\n\r\n* bind a view by its ID to a Java `View` object, idem for a list of views\r\n* bind string resources by their IDs to a Java `String` object, idem for drawables, colors, dimensions and so on\r\n* listen to the click on a view (or a list of views) by its ID and call a specific method\r\n* listen to item selection in a `ListView`\r\n* listen to some events on views like `OnCheckedChanged`, `OnEditorAction`, `OnFocusChange` ,`OnTextChanged`, etc.\r\n\r\nA huge advantage I see is that: when you add a new widget in your layout, using the \"native\" way, you should\r\n\r\n* define the associated field in your Java class\r\n* call the `findViewById` method\r\n* cast the result\r\n\r\nNow, with Butter Knife, simply define the associated field and annotate it. The `ButterKnife.bind` will replace the two next steps. So, you add a widget faster!\r\n\r\nUsing it with [its Android Studio plugin](https://github.com/avast/android-butterknife-zelezny), and you go even faster! Nothing to add!\r\n\r\n#### FragmentArgs\r\n\r\nWhen the _Fragments_ API released, this article was my guidelines: [The Android 3.0 Fragments API](http://android-developers.blogspot.fr/2011/02/android-30-fragments-api.html).\r\n\r\nBut, the more I created fragments, the more a question grew in my mind:\r\n> Is there a way to get rid of the static `newInstance` I spend so much time writing?\r\n\r\nWell OK, not so much in fact, but I found it so painful to rewrite each time to add a new fragment. That's why I looked for a way to automate it. And here comes FragmentArgs!\r\n\r\n* <http://hannesdorfmann.com/android/fragmentargs/>\r\n* <https://github.com/sockeqwe/fragmentargs>\r\n\r\nIt provides simple annotations to set up to your fragment, and the annotation processor generates you the builder class that corresponds. By using the word \"builder\", the hint is that you can specify that some parameters are optional.\r\n\r\nThat way, you gain a formal contract to create your fragment, you are sure of which parameters to provide and you reduce risks to badly configure this one.\r\n\r\n#### IntentBuilder\r\n\r\n* <https://github.com/emilsjolander/IntentBuilder>\r\n \r\nAfter using FragmentArgs, I asked myself how to start activities and services in the same way. My motivations are pretty much the same that for FragmentArgs. The collateral benefit is that I gain a similar way to build all these concepts from the Android SDK.\r\n\r\nHaving this in mind, IntentBuilder represents the perfect solution I was looking for.\r\n\r\n#### Icepick\r\n\r\n* <https://github.com/frankiesardo/icepick>\r\n \r\nAnother \"must-have library\", quoted frequently in listings!\r\n\r\nIt aims at simplifying the way to save and restore the state of activities and fragments.\r\nIt provides very clear annotations and a powerful utility class named `Icepick`.\r\n\r\n#### OnActivityResult\r\n\r\n* <https://github.com/vanniktech/OnActivityResult>\r\n\r\nAnother boilerplate code often written by an Android developer concerns the \"OnActivityResult\" part.\r\n\r\nWe have to override the `onActivityResult` method, test the request code, test the result code, and here we can deal with the result. We usually fall in a lot of nested blocks, difficult to read and understand.\r\n\r\nThis library provides a relevant answer to this issue.\r\n\r\nWith the simple `@OnActivityResult` annotation and its parameters, placed up above a method declaration, we can clearly specify the method to call in which case of activity result.\r\n\r\nThe code is definitely lighter and clearer.\r\n\r\n#### Project Lombok\r\n\r\n* <https://projectlombok.org/>\r\n\r\nIt's a famous Java project to reduce the boilerplate Java code.\r\nThe developer writes less code, so it's less error-prone and easier to read.\r\n\r\nIn an Android project, using Android Studio, it should be used in combination with the associated plugin:\r\n\r\n* <https://plugins.jetbrains.com/plugin/6317>\r\n\r\n### A new way to set up `ListView`/`RecyclerView`: Smart Adapters\r\n\r\n* Smart Adapters: \r\n\t* <https://github.com/mrmans0n/smart-adapters>\r\n\r\nThe advantages I see:\r\n\r\n* No need to write the redundant code of an adapter with its `getCount` methods and so on\r\n* A dedicated class to manage the view to display to, that has more meaning that adapter one for me\r\n* No more hand-handling of the _ViewHolder_ pattern\r\n* An easy binding in few lines in the worker class\r\n* Works well with Butter Knife\r\n* A fully-customizable listener engine\r\n* A powerful way to custom binding of a given _Model_ class to many _View_ class, delegating responsibility to choose right _View_ to a dedicated _Builder_ class\r\n\r\nThe drawbacks I see:\r\n\r\n* Currently not working with `Cursor`\r\n\r\n#### An alternative: generics, `Cursor`, Michelangelo and MicroOrm\r\n\r\nIt's possible to write a generic `Adapter` class in the same way it's presented in this repository:\r\n\r\n* <https://github.com/blacroix/viewholder_customview_generic/tree/master/app/src/main/java/fr/blacroix/generic>\r\n\r\nIt's possible to turn it so that it can manage a `Cursor`.\r\n\r\nHere comes a powerful library to inflate and bind `View`: [Michelangelo](https://github.com/RomainPiel/Michelangelo).\r\n\r\nNow, an easy way to retrieve values from a `Cursor` could be to use of the [MicroOrm library](https://github.com/chalup/microorm) (as you can see in a previous section).\r\n\r\n### Welcome to a Lambda Expressions world from Java 8 thanks to `Retrolambda`\r\n\r\nA major contribution of Java 8 is the lambda expressions.\r\n\r\nIt's like the _closures_ of languages such as Groovy or Scala for example. The idea is to provide a reference mechanism to write anonymous code blocks.\r\n\r\nIn functional languages, this feature is very useful. For example, it allows developers to pass a function \"B\" as a parameter of a function \"A\", making this \"A\" function reusable and easy to test. \r\n\r\nTo do so similar technique in Java, we often have to declare an interface \"B\" and provide an anonymous implementation to the function \"A\". Quite verbose (and boring)!\r\n\r\nLambda expressions provide an attractive alternative since it simplifies the use of interfaces with a single abstract method (i.e., \"SAM interfaces\" or \"Functional Interfaces\"), such as `Runnable`, `Comparator` and multiple _listeners_ in the Android SDK.\r\n\r\nIt has a very fluent syntax:\r\n\r\n```java\r\n(parameters) -> simple statement\r\n\r\n// or\r\n\r\n(parameters) -> { statements block }\r\n```\r\n\r\nIn my Android projects, I use it to significantly reduce the size of my source code. Each time I have to deal with a SAM interface, I can use a lambda expression. By the way, it's frequent that Android Studio advises me to replace my code with a lambda expression!\r\n\r\nTo do so, I have to include [Gradle Retrolambda Plugin](https://github.com/evant/gradle-retrolambda) to my project.\r\n\r\nHere is a snippet of me `build.gradle` file:\r\n\r\n```groovy\r\nbuildscript {\r\n    repositories {\r\n        mavenCentral()\r\n    }\r\n    dependencies {\r\n        // ...\r\n        classpath 'me.tatarka:gradle-retrolambda:3.2.5'\r\n    }\r\n}\r\n\r\nrepositories {\r\n  mavenCentral()\r\n}\r\n\r\n// ...\r\napply plugin: 'me.tatarka.retrolambda'\r\n\r\nandroid {\r\n\r\n    // ...\r\n    \r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_1_8\r\n        targetCompatibility JavaVersion.VERSION_1_8\r\n    }\r\n}\r\n\r\nretrolambda {\r\n    jvmArgs '-noverify'\r\n}\r\n```\r\n\r\nAnd here we are!\r\n\r\n### Simplify the logic to switch between _LCE_ views \r\n\r\nLCE is an acronym (I knew thanks to the Mosby articles) to describe the traditional Loading-Content-Error views an `Activity` or `Fragment` could manage. I just would like to add the _Empty_ view keyword.\r\n\r\nIt's a common task to switch from one `View` to another according to user interactions and/or jobs execution. It could easily become a complex lot of methods with boolean parameters to represent the view state. Not easy to set up and not easy to read when coming back to the project a few months later.\r\n\r\nI looked for various approaches to simplify this (error-prone) task.\r\nAnd a relevant answer I found is the use of the Switcher library.\r\n \r\n* <https://github.com/jkwiecien/Switcher>\r\n\r\nIt's very simple to set up. Just declare your widgets in layouts, as usual.\r\nAnd in your activity or fragment class, you build a new instance of `Switcher`.\r\nYou set up the various views it has to play with:\r\n\r\n```java\r\nswitcher = new Switcher.Builder(this)\r\n                .addContentView(findViewById(R.id.recycler_view)) // content member\r\n                .addErrorView(findViewById(R.id.error_view)) // error view member\r\n                .addProgressView(findViewById(R.id.progress_view)) // progress view member\r\n                .addEmptyView(findViewById(R.id.empty_view)) // empty placeholder member\r\n                .build();\r\n```\r\n\r\nAnd then you just have to call the suitable method when needed:\r\n\r\n```java\r\nswitcher.showContentView();\r\nswitcher.showProgressView();\r\nswitcher.showErrorView();\r\nswitcher.showEmptyView();\r\n```\r\n\r\nAnd here you gain a fluent way to play with your views visibility and have a consistent view state machine.\r\n\r\n## Testing\r\n\r\nThe first step to write unit tests on Android is to set up our `build.gradle` file to be able to use JUnit and its `AndroidJUnitRunner` and write JUnit 4.x tests.\r\n\r\nTo do so, we follow the documentation from the [Android Testing Support Library](https://google.github.io/android-testing-support-library)\r\n\r\nSo our `build.gradle` looks like:\r\n\r\n```groovy\r\nandroid {\r\n    // ...\r\n\r\n    defaultConfig {\r\n        // ...\r\n\r\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\r\n    }\r\n    // ...\r\n}\r\n\r\ndependencies {\r\n    androidTestCompile 'com.android.support:support-annotations:23.1.1'\r\n    androidTestCompile 'com.android.support.test:runner:0.4.1'\r\n    androidTestCompile 'com.android.support.test:rules:0.4.1'\r\n}\r\n```\r\n\r\nThe `support-annotations` allows us to use JUnit specific annotations to configure the test run.\r\n\r\nThis way, we can define JUnit 4.x tests like:\r\n\r\n```java\r\n@RunWith(AndroidJUnit4.class)\r\n@LargeTest\r\npublic class TestClass {\r\n\r\n    //region Test lifecycle\r\n    @Before\r\n    public void setUp() {\r\n    }\r\n\r\n    @After\r\n    public void tearDown() {\r\n    }\r\n    //endregion\r\n\r\n    //region Test methods\r\n    @Test\r\n    public void testMethod() {\r\n        // TODO write test\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\n### Write tests the BDD way\r\n\r\nA trend I love when writing tests is to use the \"given/when/then\" canvas. The result is an organized writing of test methods, following a specific requirement that can serve as technical documentation.\r\n\r\nThat's why I wonder \"how to write better unit tests for my Android projects?\"\r\n\r\nA first answer I found was to use Java labels such as:\r\n\r\n```java\r\npublic void test_A_Test_Method() throws IOException {\r\n    Given:\r\n    {\r\n        // 'given' statements\r\n    }\r\n\r\n    When:\r\n    {\r\n        // 'when' statements\r\n    }\r\n\r\n    Then:\r\n    {\r\n        // 'then' statements\r\n    }\r\n}\r\n```\r\n\r\nNothing special, except the structure of the tree steps of this canvas to three \"blocks\" of Java code, prefixed with specific labels.\r\n\r\nAnother tool I came with is the very attractive [Frutilla](https://github.com/ignaciotcrespo/frutilla).\r\n\r\n![Frutilla logo](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/logo_frutilla.jpg)\r\n\r\nThe idea is to describe the tests in plain text thanks to Java annotations, as follows:\r\n\r\n```java\r\n@RunWith(value = org.frutilla.FrutillaTestRunner.class)\r\npublic class FrutillaExamplesWithAnnotationTest {\r\n\r\n    @Frutilla(\r\n        Given = \"a test with Frutilla annotations\",\r\n        When = \"it fails due to an error\",\r\n        Then = \"it shows the test description in the stacktrace\"\r\n    )\r\n    @Test\r\n    public void testError() {\r\n        throw new RuntimeException(\"forced error\");\r\n    }\r\n\r\n}\r\n```\r\n\r\nThe first benefit is that the test method explains itself in a specific use case.\r\nNext, when a test fails, the stack trace becomes very clear and describes precisely the failing use case.\r\n\r\n### Fluent assertions\r\n\r\nTo make it easier to write tests, I like to use third-party libraries that provide fluent API, such as:\r\n\r\n* Truth: <http://google.github.io/truth/>\r\n* AssertJ: <http://joel-costigliola.github.io/assertj/assertj-core.html>\r\n\r\nWhere developers formerly wrote:\r\n\r\n```java\r\nimport static org.junit.Assert.assertTrue;\r\n\r\nSet<Foo> foo = ...;\r\nassertTrue(foo.isEmpty());\r\n```\r\n\r\nthen now can write:\r\n\r\n```java\r\nimport static com.google.common.truth.Truth.assertThat;\r\n\r\nSet<Foo> foo = ...;\r\nassertThat(foo).isEmpty();\r\n```\r\n\r\nThe first advantage is that it makes tests easier to read. Another one is that the failure messages are more meaningful.\r\n\r\nSquare also released a library to write specific assertions to Android views:\r\n\r\n* AssertJ Android:  <http://square.github.io/assertj-android/>\r\n\r\n### Mocking\r\n\r\nTo mock the behavior of some components of my projects, I use the [Mockito library](http://site.mockito.org).\r\n\r\n![Mockito logo](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/logo_mockito.png)\r\n\r\nConsidering I'm in a Multidex project, I have to configure my `build.gradle` as follows:\r\n\r\n```groovy\r\n    androidTestCompile 'org.mockito:mockito-core:1.10.19'\r\n    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'\r\n```\r\n\r\nFor example, I wanted to mock my _image loader_ component (in this case, I use [Picasso](http://square.github.io/picasso/)). So I mocked this component and its Dagger2 module as follows:\r\n\r\n```java\r\n    private final Picasso mPicasso = mock(Picasso.class);\r\n    private final PicassoModule mPicassoModule = mock(PicassoModule.class);\r\n    \r\n    public Picasso getPicasso() {\r\n        return mPicasso;\r\n    }\r\n```\r\n\r\nSo when starting UI testing, this code allows me to mock the behavior of Picasso. Afterwards I can check the calls that were made to this component, thanks to Mockito's API:\r\n\r\n```java\r\nverify(mModuleRest.getPicasso(), times(1)).load(\"a test url\");\r\n```\r\n\r\nOther well-known mocking libraries are commonly used across the Android ecosystem. Just to quote them:\r\n\r\n* Robolectric: <http://robolectric.org/>\r\n\r\n![Robolectric logo](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/logo_robolectric.png)\r\n\r\n* PowerMock: <https://github.com/jayway/powermock>\r\n\r\n![PowerMock logo](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/logo_powermock.png)\r\n\r\n### UI testing\r\n\r\nAnother well-known testing library is [Robotium](https://github.com/robotiumtech/robotium). It's very powerful to describe and run UI tests.\r\n\r\n![Robotium logo](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/logo_robotium.png)\r\n\r\nTo set it up, we have to use it in combination with the [`ActivityTestRule`](http://developer.android.com/reference/android/support/test/rule/ActivityTestRule.html). This one allows us to write tests concerning an Android `Activity`. Then we get this `Activity` to configure our `Solo` instance. This `Solo` class is the entry point of the Robotium tool. This class provides a wide set of methods to reproduce the user behavior.\r\n\r\nTo make it easier to write Robotium test cases, I wrote an abstract and generic test class:\r\n\r\n```java\r\npublic abstract class AbstractRobotiumTestCase<TypeActivity extends Activity> {\r\n    //region Rule\r\n    @Rule\r\n    public final ActivityTestRule<TypeActivity> mActivityTestRule;\r\n    //endregion\r\n\r\n    //region Fields\r\n    protected Solo mSolo;\r\n    protected TypeActivity mActivity;\r\n    protected Context mContextTest;\r\n    protected Context mContextTarget;\r\n    //endregion\r\n\r\n    //region Constructor\r\n    protected AbstractRobotiumTestCase(final ActivityTestRule<TypeActivity> poActivityTestRule) {\r\n        mActivityTestRule = poActivityTestRule;\r\n    }\r\n    //endregion\r\n\r\n    //region Test lifecycle\r\n    @Before\r\n    public void setUp() throws Exception {\r\n        mActivity = mActivityTestRule.getActivity();\r\n        mSolo = new Solo(InstrumentationRegistry.getInstrumentation(), mActivity);\r\n        mContextTest = InstrumentationRegistry.getContext();\r\n        mContextTarget = InstrumentationRegistry.getTargetContext();\r\n    }\r\n\r\n    @After\r\n    public void tearDown() throws Exception {\r\n        mSolo.finishOpenedActivities();\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nSo now, to add a new test case for a specific `Activity`, I just have to subclass this `AbstractRobotiumTestCase` as follows:\r\n\r\n```java\r\n@LargeTest\r\npublic class TestMyCustomActivity extends AbstractRobotiumTestCase<MyCustomActivity> {\r\n\r\n    //region Constructor matching super\r\n    public TestMyCustomActivity() {\r\n        super(new ActivityTestRule<>(MyCustomActivity.class, true, false));\r\n    }\r\n    //endregion\r\n\r\n    //region Test lifecycle\r\n    @Before\r\n    @Override\r\n    public void setUp() throws Exception {\r\n        super.setUp();\r\n        \r\n        // set up statements\r\n    }\r\n    \r\n    @After\r\n    @Override\r\n    public void tearDown() throws Exception {\r\n        super.tearDown();\r\n        \r\n        // tear down statements\r\n        \r\n        if(mActivity != null) {\r\n            mActivity.finish();\r\n        }\r\n    }\r\n    //endregion\r\n\r\n    //region Test methods\r\n    @Test\r\n    public void test_A_Test_Method() {\r\n        Given:\r\n        {\r\n            // 'given' statements\r\n            mActivity = mActivityTestRule.launchActivity(null);\r\n        }\r\n\r\n        When:\r\n        {\r\n            // 'when' statements\r\n        }\r\n\r\n        Then:\r\n        {\r\n            // 'then' statements\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nI pass `false` as the third parameter to the `ActivityTestRule` constructor so it doesn't start the activity by default. Then, I launch the activity at the end of my \"given\" block, after all the initializations I need.\r\nBy calling `mActivityTestRule.launchActivity(null)`, I notify the test rule to build the default `Intent` (thanks to the `null` parameter) and start it. It returns an instance of the started activity.\r\n\r\n### Combination with dependency injection\r\n\r\nA point of interest for us is to turn off some features and replace them with mocks when running our tests. Thanks to Dagger2, it becomes easy to do so.\r\n\r\nFirst, let's have a look to my `Application` subclass:\r\n\r\n```java\r\n@AutoComponent(\r\n        modules = {\r\n                ModuleAsync.class,\r\n                ModuleBus.class,\r\n                ModuleContext.class,\r\n                ModuleDatabase.class,\r\n                ModuleEnvironment.class,\r\n                ModuleRest.class,\r\n                ModuleTransformer.class\r\n        }\r\n)\r\n@Singleton\r\n@AutoInjector(ApplicationAndroidStarter.class)\r\npublic class ApplicationAndroidStarter extends Application {\r\n    //region Singleton\r\n    protected static ApplicationAndroidStarter sSharedApplication;\r\n\r\n    public static ApplicationAndroidStarter sharedApplication() {\r\n        return sSharedApplication;\r\n    }\r\n    //endregion\r\n\r\n    //region Component\r\n    protected ApplicationAndroidStarterComponent mComponentApplication;\r\n    //endregion\r\n    \r\n    // ...\r\n\r\n    //region Overridden methods\r\n    @Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n        sSharedApplication = this;\r\n        \r\n        buildComponent();\r\n        \r\n        // ...\r\n    }\r\n\r\n    @Override\r\n    public void onTerminate() {\r\n        super.onTerminate();\r\n        sSharedApplication = null;\r\n        // ...\r\n    }\r\n    //endregion\r\n\r\n    //region Getters\r\n    public ApplicationAndroidStarterComponent componentApplication() {\r\n        return mComponentApplication;\r\n    }\r\n    //endregion\r\n\r\n    //region Protected methods\r\n    protected void buildComponent() {\r\n        mComponentApplication = DaggerApplicationAndroidStarterComponent.builder()\r\n                .moduleAsync(new ModuleAsync())\r\n                .moduleBus(new ModuleBus())\r\n                .moduleContext(new ModuleContext(getApplicationContext()))\r\n                .moduleDatabase(new ModuleDatabase())\r\n                .moduleEnvironment(new ModuleEnvironment())\r\n                .moduleRest(new ModuleRest())\r\n                .moduleTransformer(new ModuleTransformer())\r\n                .build();\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nIt's the entry point where each element asks for its dependencies. Now, the idea is to subclass it in my test project, as follows:\r\n\r\n```java\r\npublic class MockApplication extends ApplicationAndroidStarter {\r\n\r\n    //region Fields\r\n    private ModuleBus mModuleBus;\r\n    private MockModuleRest mModuleRest;\r\n    private ModuleEnvironment mModuleEnvironment;\r\n    //endregion\r\n\r\n    //region Singleton\r\n    protected static MockApplication sSharedMockApplication;\r\n\r\n    public static MockApplication sharedMockApplication() {\r\n        return sSharedMockApplication;\r\n    }\r\n    //endregion\r\n\r\n    //region Lifecycle\r\n    @Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n        sSharedMockApplication = this;\r\n    }\r\n    //endregion\r\n\r\n    //region Overridden method\r\n    @Override\r\n    protected void buildComponent() {\r\n        mModuleBus = new ModuleBus();\r\n        mModuleRest = new MockModuleRest();\r\n        mModuleEnvironment = new MockModuleEnvironment();\r\n\r\n        mComponentApplication = DaggerApplicationAndroidStarterComponent.builder()\r\n                .moduleAsync(new ModuleAsync())\r\n                .moduleBus(mModuleBus)\r\n                .moduleContext(new ModuleContext(getApplicationContext()))\r\n                .moduleDatabase(new MockModuleDatabase())\r\n                .moduleEnvironment(mModuleEnvironment)\r\n                .moduleRest(mModuleRest)\r\n                .moduleTransformer(new ModuleTransformer())\r\n                .build();\r\n    }\r\n    //endregion\r\n\r\n    //region Getters\r\n    public MockModuleRest getModuleRest() {\r\n        return mModuleRest;\r\n    }\r\n\r\n    public ModuleBus getModuleBus() {\r\n        return mModuleBus;\r\n    }\r\n\r\n    public ModuleEnvironment getModuleEnvironment() {\r\n        return mModuleEnvironment;\r\n    }\r\n    //endregion\r\n}\r\n```\r\n\r\nHere I need to mock my `ModuleRest` for example. I can do so thanks to the following code:\r\n\r\n```java\r\n@Module\r\npublic class MockModuleRest extends ModuleRest {\r\n    //region Fields\r\n    private final MockWebServer mMockWebServer;\r\n    //endregion\r\n\r\n    //region Constructor\r\n    public MockModuleRest() {\r\n        mMockWebServer = new MockWebServer();\r\n    }\r\n    //endregion\r\n\r\n    //region Modules\r\n    @Override\r\n    public GitHubService provideGithubService(@NonNull final OkHttpClient poOkHttpClient) {\r\n        final Retrofit loRetrofit = new Retrofit.Builder()\r\n                .baseUrl(mMockWebServer.url(\"/\").toString())\r\n                .addConverterFactory(JacksonConverterFactory.create())\r\n                .build();\r\n        return loRetrofit.create(GitHubService.class);\r\n    }\r\n    //endregion\r\n\r\n    //region Getters\r\n    public MockWebServer getMockWebServer() {\r\n        return mMockWebServer;\r\n    }\r\n    //endregion\r\n\r\n    //region Visible API\r\n    public void setUp() {\r\n        mMockWebServer = new MockWebServer();\r\n    }\r\n    //endregion\r\n}\r\n```\r\nI lean on [MockWebServer](https://github.com/square/okhttp/tree/master/mockwebserver) to queue up mock responses. This way, each time a REST call is made, it will deal with the mock responses I declared.\r\n\r\nThe next point is: to use this mock application, we should configure our test project. It begins with the creation of a custom `AndroidJUnitRunner` to declare the `Application` subclass to use:\r\n\r\n```java\r\npublic class AndroidStarterTestRunner extends AndroidJUnitRunner {\r\n\r\n    //region Overridden method\r\n    @Override\r\n    public void onCreate(final Bundle poArguments) {\r\n        MultiDex.install(this.getTargetContext());\r\n        super.onCreate(poArguments);\r\n    }\r\n\r\n    @Override\r\n    public Application newApplication(\r\n            final ClassLoader poClassLoader,\r\n            final String psClassName,\r\n            final Context poContext) throws InstantiationException, IllegalAccessException, ClassNotFoundException {\r\n        return super.newApplication(poClassLoader, MockApplication.class.getName(), poContext);\r\n    }\r\n    //endregion\r\n\r\n}\r\n```\r\n\r\nNow, we simply have to change our `build.gradle` file to point to his `AndroidJUnitRunner`:\r\n\r\n```groovy\r\nandroid {\r\n    // ...\r\n    \r\n    defaultConfig {\r\n        // ...\r\n\r\n        testInstrumentationRunner \"fr.guddy.androidstarter.tests.runner.AndroidStarterTestRunner\"\r\n    }\r\n```\r\n\r\nFinally, in our test case, we can queue up mock responses as follows:\r\n\r\n```java\r\npublic class ATestCase {\r\n\r\n    //region Fields\r\n    private MockModuleRest mModuleRest;\r\n    //endregion\r\n\r\n    //region Test lifecycle\r\n    @Before\r\n    @Override\r\n    public void setUp() throws Exception {\r\n        // ...\r\n        \r\n        // get the mock REST module\r\n        mModuleRest = MockApplication.sharedMockApplication().getModuleRest();\r\n    }\r\n\r\n    @After\r\n    @Override\r\n    public void tearDown() throws Exception {\r\n        super.tearDown();\r\n        try {\r\n            mMockWebServer.shutdown();\r\n        } catch (final Exception loException) {\r\n            loException.printStackTrace();\r\n        }\r\n    }\r\n    //endregion\r\n\r\n    //region Test methods\r\n    @Test\r\n    public void test_A_Test_Method() {\r\n        Given:\r\n        {\r\n            final String lsSpecificJSONData = /* specific JSON data*/;\r\n            final MockResponse loMockResponse = new MockResponse().setResponseCode(/* HTTP status code */);\r\n            loMockResponse.setBody(lsSpecificJSONData);\r\n            mModuleRest.getMockWebServer().enqueue(loMockResponse);\r\n            try {\r\n                mMockWebServer.start(/* the mock web server port */);\r\n            } catch (final Exception loException) {\r\n                loException.printStackTrace();\r\n            }\r\n            // 'then' statements\r\n        }\r\n\r\n        When:\r\n        {\r\n            // 'when' statements\r\n        }\r\n\r\n        Then:\r\n        {\r\n            // 'then' statements\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis example is focused on REST communications, but it can be applied to various layers such as persistence for example.\r\n\r\nMoreover, the example shown queues up only one mock response, but it becomes possible to add multiple responses to build more complex scenarios.\r\n\r\n## Code coverage\r\n\r\nAndroid SDK comes with [Emma Code Coverage](http://emma.sourceforge.net/). We can activate the code coverage in the `build.gradle` file, as follows:\r\n\r\n```groovy\r\nandroid {\r\n   buildTypes {\r\n      debug {\r\n         testCoverageEnabled = true\r\n      }\r\n   }\r\n}\r\n```\r\n\r\nRunning the `gradle tasks` command, we can see:\r\n\r\n```\r\ncreateDebugCoverageReport - Creates test coverage reports for the debug variant.\r\n```\r\n\r\nSo to get the code coverage report, we need to run this Gradle task `createDebugCoverageReport`:\r\n\r\n```\r\ngradle createDebugCoverageReport\r\n```\r\n\r\nNow we can find the report in the `{main_module}/build/reports/coverage/debug` directory. We just need to open the `index.html` file in a Web browser to view the report.\r\n\r\n![Code coverage screenshot](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/code_coverage_report.png)\r\n\r\n## Relevant libraries\r\n\r\n* Arrow: \r\n\t* <https://github.com/android10/arrow>\r\n\t\r\n\t> Arrow is a Lightweight library toolbox for Java and Android Development.\r\n\r\n\t![Arrow logo](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/logo_arrow.jpg)\r\n\t\r\n* Paperwork\r\n\t> Generate build info for your Android project without breaking incremental compilation\r\n\t* <https://github.com/zsoltk/paperwork>\r\n* Logger:\r\n\t* <https://github.com/orhanobut/logger>\r\n* hugo: \r\n\t* <https://github.com/JakeWharton/hugo>\r\n* Frodo:\r\n\t* <https://github.com/android10/frodo>\r\n\t\r\n\t> Android Library for Logging RxJava Observables and Subscribers.\r\n* Lynx:\r\n\t* <https://github.com/pedrovgs/Lynx>\r\n\t\r\n\t> Lynx is an Android library created to show a custom view with all the information Android logcat is printing, different traces of different levels will be rendered to show from log messages to your application exceptions.\r\n* FluentView:\r\n\t* <https://github.com/nantaphop/FluentView>\r\n\t\r\n\t> Android Library for Setting a View via Fluent Interface\r\n\r\n\t![FluentView logo](https://raw.githubusercontent.com/RoRoche/AndroidStarter/master/assets/logo_fluentview.jpeg)\r\n\r\n## Relevant tools\r\n\r\n* Scalpel\r\n\t* <https://github.com/JakeWharton/scalpel>\r\n\t\r\n\t> A surgical debugging tool to uncover the layers under your app.\r\n* LeakCanary\r\n\t* <https://github.com/square/leakcanary>\r\n\t\r\n\t> A memory leak detection library for Android and Java.\r\n* DebugDrawer\r\n\t* <https://github.com/palaima/DebugDrawer>\r\n\t\r\n\t> Android Debug Drawer for faster development\r\n* Android Asset Studio\r\n\t* <http://romannurik.github.io/AndroidAssetStudio/>\r\n* Fabric\r\n\t* <https://fabric.io/>\r\n\t* <https://fabric.io/kits/android/crashlytics/summary>\r\n* Vector Asset Studio\r\n\t* <http://developer.android.com/tools/help/vector-asset-studio.html>\r\n\t\r\n\t> Vector Asset Studio helps you add material icons and import Scalable Vector Graphic (SVG) files into your app project as a drawable resource.\r\n\r\n## Relevant resources\r\n\r\n* Android Arsenal\r\n\t* <http://android-arsenal.com>\r\n* androidweekly:\r\n\t* <http://androidweekly.net/>\r\n* Gradle tips & tricks:\r\n\t* <https://medium.com/@cesarmcferreira/gradle-tips-tricks-to-survive-the-zombie-apocalypse-3dd996604341>\r\n* RxAndroidLibs\r\n\t* <https://github.com/zsoltk/RxAndroidLibs>\r\n* AndroidLibs\r\n\t* <https://android-libs.com/>\r\n\r\n## Bibliography\r\n\r\n* Android DataBinding:\r\n\t* <http://www.opgenorth.net/blog/2015/09/15/android-data-binding-intro/>\r\n* Code coverage\r\n\t* <http://blog.wittchen.biz.pl/test-coverage-report-for-android-application/>\r\n* Dagger2: \r\n\t* <http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/>\r\n\t* <https://blog.gouline.net/2015/05/04/dagger-2-even-sharper-less-square/>\r\n\t* <http://code.tutsplus.com/tutorials/dependency-injection-with-dagger-2-on-android--cms-23345>\r\n\t* <https://www.future-processing.pl/blog/dependency-injection-with-dagger-2/>\r\n* Retrolambda: \r\n\t* <http://www.vogella.com/tutorials/Retrolambda/article.html>\r\n* RxJava:\r\n\t* <http://blog.soat.fr/2015/06/rxjava-ecriture-de-code-asynchrone/>\r\n\t* <http://blog.xebia.fr/2014/01/10/android-oubliez-definitivement-les-asynctask-avec-rxjava/>\r\n\t* <https://github.com/ReactiveX/RxAndroid>\r\n\t* <http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/>\r\n* Testing:\r\n\t* <https://prezi.com/fxxkpgakbivh/behaviour-driven-development-in-android-studio/>\r\n\t* <http://fedepaol.github.io/blog/2015/09/05/mocking-with-robolectric-and-dagger-2/>\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}